{
  "hash": "78ff6c56ec7671b423ba3c152114725d",
  "result": {
    "markdown": "---\ntitle: Adding Alpha Masks to the Quartz Graphics Device # Warning: changing the title may create a new Discussions thread!\ndescription: \"\" # Optional short description for post on Discussions thread\nauthor: Paul Murrell\noutput: html_document\ncategories: [C, MacOS, Graphics]\ncomments:\n  giscus: \n    repo: \"r-devel/r-project-sprint-2023\"\n    repo-id: \"R_kgDOIhAibA\"\n    category: \"Proposals\"\n    category-id: \"DIC_kwDOIhAibM4CW3GY\"\n    mapping: \"title\"\n    reactions-enabled: true\n    loading: lazy\n---\n\n\n## Background\n\nR version 4.1 added the concept of alpha masks to R graphics, with an interface in the 'grid' graphics system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(grid)\n```\n:::\n\n\nAny shape(s) can be used to create an alpha mask, but the only thing that matters is the opacity of the final result. The mask below is based on a circle, the important part being that it has a semitransparent fill (a line segment is drawn to show that the circle is semitransparent; the line is visible through the circle). Outside the circle, where we have drawn nothing, the mask is fully transparent.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nac <- circleGrob(r=.3, gp=gpar(col=NA, fill=rgb(0,0,0,.5)))\namask <- as.mask(ac)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/draw-circle-mask-1.png){width=192}\n:::\n:::\n\n\nWe can apply a mask to affect what happens when we draw other shapes. For example, we will work with the following rectangles, one tall and thin and red and one short and wide and green.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr1 <- rectGrob(width=.2, gp=gpar(fill=2))\nr2 <- rectGrob(height=.2, gp=gpar(fill=3))\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/draw-rect-1.png){width=192}\n:::\n:::\n\n\nThe following code defines a simple function with a mask as its argument. It draws the red rectangle, then pushes a viewport that enforces the mask, then draws the green rectangle.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaskTest <- function(mask) {\n    grid.rect()\n    grid.draw(r1)\n    pushViewport(viewport(mask=mask))\n    grid.draw(r2)\n    popViewport()\n}\n```\n:::\n\n\nThe followind code calls that function, passing the `amask` defined above. The drawing is done on a `pdf()` graphics device for reasons that will become clear later. The result is that the red rectangle is drawn normally, but the mask means that only part of the green rectangle is drawn (where the rectangle and the circlular mask overlap) and that part is only drawn semitransparent (because the mask is semitransparent).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npdf(\"alpha-mask.pdf\", width=2, height=2)\nmaskTest(amask)\ndev.off()\n```\n:::\n\n\n![](alpha-mask.png)\n\nR version 4.2 added the concept of *luminance* masks. As with alpha masks, we can create a luminance masks with any shape, but what matters is not the opacity of the final result, but the luminance of the final result; whether the mask is black (which corresponds to full transparency), or white (full opacity), or grey (semitransparency).\n\nWe will again work with a mask based on a circle, but this time the circle just has an opaque grey fill (we cannot see the line segment through the circle).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlc <- circleGrob(r=.3, gp=gpar(col=NA, fill=\"grey50\"))\nlmask <- as.mask(lc, type=\"luminance\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/draw-lumi-mask-1.png){width=192}\n:::\n:::\n\n\nThe following code calls the `maskTest()` function again, but this time using the `lmask`. The result is the same as for the alpha mask, but this time the result is due to the grey values in the luminance mask, where before the result was due to the opacity value in the alpha mask. Again, we use the `pdf()` device for drawing; this will become clear very soon, I promise!\n\n\n::: {.cell}\n\n```{.r .cell-code}\npdf(\"lumi-mask.pdf\", width=2, height=2)\nmaskTest(lmask)\ndev.off()\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n![](lumi-mask.png)\n\n## Problem statement\n\nNot all graphics devices support masks. For those that do, not all devices support both alpha masks and luminance masks. For example, although the `pdf()` device used above supports both types of masks, Cairo-based graphics devices, e.g., `png(type=\"cairo\")`, only support alpha masks. If you try `maskTest(lmask)` on a Cairo graphics device you will get a warning and the mask with have no effect.\n\nIn R version 4.3, support for luminance masks was added to the Quartz graphics device in R (`quartz()` on MacOS). Unfortunately, in a reverse of the Cairo graphics device problem, Quartz graphics only supports luminance masks so we have not implemented alpha masks on the `quartz()` device. If you try `maskTest(amask)` on a `quartz()` device, you will get a warning and the mask with have no effect.\n\n## Proposed solution\n\nThe implementation of luminance masks for the `quartz()` device involves creating a greyscale bitmap image and drawing the mask shapes onto that. This happens in the C function `QuartzCreateMask()` (in `R/src/library/grDevices/src/devQuartz.c`). The Quartz function `CGContextClipToMask()` uses that greyscale image to clip output.\n\nThe proposal is that an alpha mask could be implemented by creating an RGBA bitmap image (instead of a greyscale image) for drawing the mask shapes onto and then converting that image to a greyscale one based on the alpha channel of the RGBA image. Once we have a greyscale image from the alpha mask, we can proceed as before.\n\nThe `dev->capabilities()` of the `quartz()` device would also need updating.\n\n## Testing\n\nSome examples of R code and desired output for luminance masks are included in the technical report [\"Luminance Masks in R Graphics\"](https://stattech.wordpress.fos.auckland.ac.nz/2021/12/01/2021-04-luminance-masks-in-r-graphics/) ([faster link](https://protect-au.mimecast.com/s/SkAFCq71EMFpz5z7fZ37by?domain=stat.auckland.ac.nz)).\n\nThe ['gdiff' package](https://cran.rstudio.com/web/packages/gdiff/) can be useful for checking that test output matches control output.\n\n## Project requirements\n\nFamiliarity with C. Though there is a strong template of existing code to work from.\n\nCapability to build R from source (on MacOS).\n\nAbility to find, read, and comprehend Apple Core Graphics documentation, e.g., documentation for [`CGContextClipToMask()`](https://developer.apple.com/documentation/coregraphics/1456497-cgcontextcliptomask)\n\n## Project resources\n\n-   [\"New Features in the R Graphics Engine\"](https://developer.r-project.org/Blog/public/2020/07/15/new-features-in-the-r-graphics-engine/)\n\n-   [\"Luminance Masks in R Graphics\"](https://stattech.wordpress.fos.auckland.ac.nz/2021/12/01/2021-04-luminance-masks-in-r-graphics/).\n\n-   [\"Groups and Paths and Masks in R Graphics\"](https://developer.r-project.org/Blog/public/2021/12/06/groups-and-paths-and-masks-in-r-graphics/index.html)\n\n-   [\"Catching up with R Graphics\"](https://stattech.wordpress.fos.auckland.ac.nz/2020/07/14/2020-04-catching-up-with-r-graphics/)\n\n-   [\"Writing R Extensions\"](https://cran.r-project.org/doc/manuals/r-devel/R-exts.html)\n\n-   [\"R internals\"](https://cran.r-project.org/doc/manuals/r-devel/R-ints.html)\n\n-   Questions can be emailed to [Paul Murrell](mailto:paul@stat.auckland.ac.nz)\n\n## Project outcomes\n\nContribution to the core R code base (would need to be GPL).\n\nExperience with building R from source.\n\nExposure to the design of R graphics devices and the R graphics device API.\n\nExposure to R graphics C code, especially that involving graphics devices (`R/src/include/R_Ext/GraphicsDevice.h`), especially the `quartz()` device (`R/src/library/grDevices/src/devQuartz.c`).\n\n## Reactions and comments\n\n\n```{=html}\n<!-- \nPlease leave the Reactions and comments section\n- a Giscus comment box will be automatically added here \n-->\n```\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}