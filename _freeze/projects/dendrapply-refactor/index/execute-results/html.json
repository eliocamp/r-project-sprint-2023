{
  "hash": "00bc60e54442787ad177bd580bb8aed4",
  "result": {
    "markdown": "---\ntitle: Dendrapply Refactor # Warning: changing the title may create a new Discussions thread!\ndescription: \"\" # Optional short description for post on Discussions\nauthor: Aidan Lakshman # and co-authors if applicable\noutput: html_document\ncategories: [C, Wishlist, Low-level] # use labels from https://github.com/r-devel/r-project-sprint-2023/labels\ncomments:\n  giscus: \n    repo: \"r-devel/r-project-sprint-2023\"\n    repo-id: \"R_kgDOIhAibA\"\n    category: \"Proposals\"\n    category-id: \"DIC_kwDOIhAibM4CW3GY\"\n    mapping: \"title\"\n    reactions-enabled: true\n    loading: lazy\n---\n\n```{=html}\n<!-- \nThis template is based on https://contributor.r-project.org/r-project-sprint-2023/projects/quartz-alpha-mask/.\nThe sections are provided as a guide and may not be appropriate to your proposal, feel free to skip or change sections.\n\nPlease label any R code chunks, especially those producing images.\n-->\n```\n\n::: {.cell}\n\n:::\n\n\n## Background\n`dendrogram` objects are frequently used in a variety of analyses in R, especially in hierarchical clustering and phylogenetics. A given `dendrogram` object defines a tree-like structure, with internal nodes (nodes with more nested child nodes) and leaf nodes (nodes with no children). \n\nThe structure of this object in R is a nested list, with each element of class `dendrogram` and containing at least the `members` and `height` attribute. `members` defines the number of leaf nodes below that particular node, and `height` defines the height of the node for plotting. Leaf nodes contain an additional attribute `leaf`, which is set to `TRUE`. \n\nWorking with `dendrogram` objects is difficult due to their deep nested structure. To this end, the `dendrapply` function was created in 2004 by Dr. Maechler to apply a function to all nodes of a dendrogram. `dendrapply` is used frequently in many packages and analyses, notably `dendextend`, and its implementation is defined in `src/library/stats/R/dendrogram.R`. \n\n## Problem statement\n\nThe current implementation of `dendrapply` is included at the bottom of this section. This implementation has two main issues.\n\nThe most notable of these is the recursive application of functions to the dendrogram nodes. This leads to poor performance on deeply nested dendrograms, as well as the potential for stack overflow errors on machines with limited resources. This is detailed in `?dendrapply` and in the warning in `?dendrogram`.\n\nAdditionally, tree traversal can be achieved in a number of ways. The current implementation uses a pre-order traversal, which is not always the most intuitive application of functions to a tree structure. This means that, for each triple `2 <- 1 -> 3`, the function is applied first to node `1`, then to `2`, then to `3`. Ideally, users would be able to choose between a post-order or a pre-order traversal. Post-order traversals guarantee that the function is applied to all children of a node before applying to the parent, allowing for certain analyses that rely on propagating results up a tree. There is currently no easy way to achieve this in R.\n\nIn summary, the priorities to rectify are (in order of importance):\n\n1. Remove recursion in `dendrapply`\n2. Add an optional argument to allow for different tree traversals in function application\n\nThese must be achieved while preserving all the current functionality of `dendrapply`, and without decreasing the current performance.\n\nCurrent implementation:\n\n::: {.cell}\n\n```{.r .cell-code}\ndendrapply <- function(X, FUN, ...)\n{\n    ## Purpose: \"dendrogram\" recursive apply {to each node}\n    ## ----------------------------------------------------------------------\n    ## Author: Martin Maechler, Date: 26 Jun 2004, 22:43\n    FUN <- match.fun(FUN)\n    if( !inherits(X, \"dendrogram\") ) stop(\"'X' is not a dendrogram\")\n\n    ## Node apply recursively:\n    Napply <- function(d) {\n\tr <- FUN(d, ...)\n\tif(!is.leaf(d)) {\n\t    if(!is.list(r)) r <- as.list(r) # fixing unsafe FUN()s\n\t    if(length(r) < (n <- length(d))) r[seq_len(n)] <- vector(\"list\", n)\n\t    ## and overwrite recursively, possibly keeping \"attr\"\n\t    r[] <- lapply(d, Napply)\n        }\n\tr\n    }\n    Napply(X)\n}\n```\n:::\n\n\n## Proposed solution\n\nA full description follows, but people that are interested can read my  [initial writeup](https://www.ahl27.com/posts/2023/02/dendrapply/) for more details on the problem, attempted solutions, and current status. Feel free to skip that link and just read the following section instead.\n\nA prototype solution has been implemented and [submitted to Bugzilla](https://bugs.r-project.org/show_bug.cgi?id=18480). This solution moves the R implementation into C. The short description of the proposed method is to create a linked list in C holding the `SEXP` pointers for each node of the tree. Then, we apply the function given to each node of the linked list, and then merge the `SEXP` objects back into the original topology. This can be further optimized by merging nodes on the fly to limit linked list space and reduce `PROTECT` stack usage. This also allows for different tree traversal strategies with minimal effort, as different tree traversals can be achieved by varying how nodes are added to the linked list.\n\nThe current solution has one key issue resulting in a two problems. This implementation uses `VECTOR_ELT` rather than the more general `[[` and `[[<-` operations to get/set values. This allows for low `PROTECT` stack usage and high performance, but it also means that nodes discard their `class` values when passed to the function. This can be solved naively by just reclassing nodes as `dendrogram`, but unfortunately this causes issues in the case where nodes have multiple classes (ex. a node where `class(node ) == c('dendrogram', 'myOtherClass')`). This also runs into problems in the case where a non-standard `[[` method is implemented. In the interest of backwards compatibility, these problems should be rectified.\n\nThere are a few options for fixing this issue. The first is to work entirely in R, removing the C implementation. This would work in theory by using a list structure to hold nodes, but the linked-list structure in C gives a substantial boost in performance over R by using pointers instead of copying each object. This may not be a big deal; I haven't tested it yet. \n\nAnother possible option is to use the alternative vector-based `dendrogram` indexing ( `dend[[c(1,1)]]` is equivalent to `dend[[1]][[1]]` ) to build a list of targets first, then apply the function to each. This may solve the potential R-implementation memory issues, but could also require initializing a huge vector. Dealing with the topology of the dendrogram would also be challenging.\n\nAnother potential fix is to use the `[[` method by building an R expression in C and then calling it, similar to how `lapply` is implemented (see `do_lapply()` in `src/main/apply.c` for reference). This implementation was tested and worked successfully, but the result was significantly slower than the R version (roughly half speed, likely due to `PROTECT` stack issues mentioned below). Maybe a code refactor could solve the slowdowns and produce a better result.\n\nThe last potential fix I've identified is to use precious multi-sets for protection rather than `PROTECT`. One of the big problems of applying functions in C is that the result of the function application at each node needs to be protected. This isn't an issue for post-order traversals, since we can always just add the result as a child of the parent node (which auto-protects it if the parent is already protected). However, for the current implementation, a potentially large source of slow-downs is the work-arounds implemented to solve `PROTECT` stack issues. Using MSets could simplify this and improve runtime, but there isn't a lot of documentations on how to use them (and their use for this kind of problem is explicitly discouraged in some places).\n\n## Testing\n\nBenchmarking the function against `stats::dendrapply` can be done using the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndend <- as.dendrogram(hclust(dist(1:100)))\nf <- function(x) x\n\nmicrobenchmark::microbenchmark(stats::dendrapply(dend, f),\n                               new_dendrapply(dend, f))\n```\n:::\n\n\nDifferent dendrogram objects should be tested to look at performance on balanced vs. deep trees, but usage of `\\(x) x` is important for accurate testing. This function minimizes the amount of operations within the applied function, meaning that the vast majority of the differences in time will be due to the implementation of `dendrapply`, not the runtime of `f`.\n\nAdditional testing should be done to verify that the following work as expected:\n\n- Ensure speed of new application is at least as fast as `stats::dendrapply`\n- Ensure all examples in `?dendrapply` work as expected\n- Ensure all tests in `dendextend` work correctly to test a large set of currently used applications of `dendrapply`\n- Ensure that nodes with multiple classes retain their `class` attribute after running `dendrapply`\n- Ensure that special uses of `[[` work as expected\n- Ensure that recursive `dendrapply` calls work as expected (ex. `dendrapply(dend, \\(x) dendrapply(x, someOtherFunction))`)\n- Ensure all examples in the R build testing work as expected, paying special attention to the following weird case:\n```\n> D <- as.dendrogram(hclust(dist(cbind(setNames(c(0,1,4), LETTERS[1:3])))))\n> dendrapply(D, labels)\n[[1]]\n[1] \"C\"\n\n[[2]]\n[[2]][[1]]\n[1] \"A\"\n\n[[2]][[2]]\n[1] \"B\"\n\n[[3]]\n[1] \"C\"\n```\n\nImplementation should also be made to ensure that the default parameters are fully backwards compatible. In the case of post-order traversal, this is currently being achieved by defining the function as `dendrapply(X, FUN, ..., how=c('pre.order', 'post.order'))` so that the default is always equivalent to `stats::dendrapply`.\n\nFinally, testing should be added to the R source tests. The current testing suite for `dendrapply` is very sparse; edge cases like multi-classed `dendrogram` objects should be added to ensure code works as expected in the future.\n\n## Project requirements\n\n<!-- Include here prerequisite knowledge and any operating system requirements -->\nI suspect that the optimal solution will involve working in C, so knowledge of C to develop this will be helpful, even if just to be able to compare performance against an R implementation. Much of the implementation in C depends on knowledge of the `PROTECT` stack, so familiarity with that is important for C solutions. \n\nBasic knowledge of tree structures and/or `dendrogram` objects is helpful but not necessary.\n\n## Project resources\n\n- [Tree traversal methods](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/)\n- [My full description of problem and implementation](https://www.ahl27.com/posts/2023/02/dendrapply/)\n- [Current bugzilla ticket](https://bugs.r-project.org/show_bug.cgi?id=18480) (contains most up-to-date code; my blog post may be out of date.)\n\n## Project outcomes\n\nIf successful, we'd be able to submit a new version of `dendrapply` with better performance. Removing the recursion in this function would make these analyses also possible on edge computing and limited resource machines (or at least more feasible). Implementation of multiple traversal methods for function application would be a massive resource to the phylogenetics community.\n\n## Reactions and comments\n\n\n```{=html}\n<!-- \nPlease leave the Reactions and comments section\n- a Giscus comment box will be automatically added here \n-->\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}